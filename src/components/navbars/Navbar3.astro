---
import BrandLogo from "../BrandLogo.astro";
const { categories } = Astro.props;

// Define types for our menu categories
interface MenuCategory {
  id: string;
  title: string;
  items: any[];
}
---

<header class="fixed top-0 left-0 right-0 z-20 bg-swefish-yellow px-4 py-3 flex items-center justify-center border-b">
  <BrandLogo class="h-8 w-auto" />
</header>

<!-- Menu navigation with tabs -->
<nav class="fixed top-[52px] left-0 right-0 z-10 bg-white border-b">
  <div class="relative flex h-14">
    <!-- Menu button -->
    <button 
      id="menu-toggle" 
      class="flex items-center justify-center w-14 h-full border-r border-gray-200 hover:bg-gray-50 focus:outline-none"
      aria-expanded="false"
      aria-controls="mobile-menu"
    >
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="4" x2="20" y1="12" y2="12" />
        <line x1="4" x2="20" y1="6" y2="6" />
        <line x1="4" x2="20" y1="18" y2="18" />
      </svg>
    </button>
    
    <!-- Horizontal tabs - visible on desktop and when mobile menu is closed -->
    <div id="tabs-container" class="flex overflow-x-auto scrollbar-hide">
      {categories.map((category: MenuCategory, index: number) => (
        <a 
          href={`#${category.id}`}
          class={`flex-shrink-0 px-4 py-3 text-base font-medium whitespace-nowrap transition-colors relative ${
            index === 0 ? 'text-black' : 'text-gray-500'
          }`}
          data-category-id={category.id}
        >
          <span>{category.title}</span>
          <div class={`absolute bottom-0 left-0 h-0.5 bg-black transition-all duration-300 ${
            index === 0 ? 'w-full' : 'w-0'
          }`}></div>
        </a>
      ))}
    </div>
  </div>
  
  <!-- Mobile menu - hidden by default -->
  <div 
    id="mobile-menu" 
    class="hidden bg-white border-t"
    aria-hidden="true"
  >
    <div class="py-2 px-4">
      {categories.map((category: MenuCategory) => (
        <a 
          href={`#${category.id}`}
          class="block w-full text-left py-3 border-b border-gray-100 hover:bg-gray-50"
          data-category-id={category.id}
        >
          {category.title}
        </a>
      ))}
    </div>
  </div>
</nav>

<style>
  /* Hide scrollbar for Chrome, Safari and Opera */
  .scrollbar-hide::-webkit-scrollbar {
    display: none;
  }
  
  /* Hide scrollbar for IE, Edge and Firefox */
  .scrollbar-hide {
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
  }
  
  /* Smooth scrolling for the whole page */
  :global(html) {
    scroll-behavior: smooth;
  }
  
  /* Adjust scroll margin for sections to account for fixed header */
  :global(section[id]) {
    scroll-margin-top: 112px; /* Adjust based on your header + nav height */
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Elements
    const menuToggle = document.getElementById('menu-toggle');
    const mobileMenu = document.getElementById('mobile-menu');
    const tabsContainer = document.getElementById('tabs-container');
    const categoryLinks = document.querySelectorAll('[data-category-id]');
    
    // State
    let isMobileMenuOpen = false;
    
    // Toggle mobile menu
    if (menuToggle && mobileMenu && tabsContainer) {
      menuToggle.addEventListener('click', () => {
        isMobileMenuOpen = !isMobileMenuOpen;
        
        // Update ARIA attributes
        menuToggle.setAttribute('aria-expanded', isMobileMenuOpen.toString());
        mobileMenu.setAttribute('aria-hidden', (!isMobileMenuOpen).toString());
        
        // Toggle visibility
        if (isMobileMenuOpen) {
          mobileMenu.classList.remove('hidden');
          tabsContainer.classList.add('hidden');
          menuToggle.classList.add('text-black');
        } else {
          mobileMenu.classList.add('hidden');
          tabsContainer.classList.remove('hidden');
          menuToggle.classList.remove('text-black');
        }
      });
    }
    
    // Handle category link clicks
    categoryLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        // Close mobile menu if open
        if (isMobileMenuOpen && menuToggle && mobileMenu && tabsContainer) {
          isMobileMenuOpen = false;
          menuToggle.setAttribute('aria-expanded', 'false');
          mobileMenu.setAttribute('aria-hidden', 'true');
          mobileMenu.classList.add('hidden');
          tabsContainer.classList.remove('hidden');
          menuToggle.classList.remove('text-black');
        }
        
        // Update active tab
        const categoryId = link.getAttribute('data-category-id');
        if (categoryId) {
          updateActiveTab(categoryId);
        }
      });
    });
    
    // Update active tab based on scroll position
    function updateActiveTab(categoryId: string): void {
      // Remove active state from all tabs
      categoryLinks.forEach(link => {
        link.classList.remove('text-black');
        link.classList.add('text-gray-500');
        const indicator = link.querySelector('div');
        if (indicator) {
          indicator.classList.remove('w-full');
          indicator.classList.add('w-0');
        }
      });
      
      // Add active state to current tab
      const activeLink = document.querySelector(`[data-category-id="${categoryId}"]`);
      if (activeLink) {
        activeLink.classList.remove('text-gray-500');
        activeLink.classList.add('text-black');
        const indicator = activeLink.querySelector('div');
        if (indicator) {
          indicator.classList.remove('w-0');
          indicator.classList.add('w-full');
        }
      }
    }
    
    // Use Intersection Observer for scrollspy
    const header = document.querySelector('header');
    const nav = document.querySelector('nav');
    
    if (header && nav) {
      const navbarHeight = header.offsetHeight + nav.offsetHeight;
      
      const observerOptions = {
        root: null,
        rootMargin: `-${navbarHeight}px 0px -50% 0px`,
        threshold: 0.1
      };
      
      const observerCallback = (entries: IntersectionObserverEntry[]): void => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const sectionId = entry.target.id;
            updateActiveTab(sectionId);
          }
        });
      };
      
      const observer = new IntersectionObserver(observerCallback, observerOptions);
      
      // Observe all sections
      document.querySelectorAll('section[id]').forEach(section => {
        observer.observe(section);
      });
      
      // Initialize with the first visible section
      setTimeout(() => {
        const sections = Array.from(document.querySelectorAll('section[id]'));
        const visibleSection = sections.find(section => {
          const rect = section.getBoundingClientRect();
          return rect.top < window.innerHeight * 0.5 && rect.bottom > navbarHeight;
        });
        
        if (visibleSection) {
          updateActiveTab(visibleSection.id);
        }
      }, 100);
    }
  });
</script>

