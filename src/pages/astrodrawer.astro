---
// Define props for the drawer component
const {
  id = "drawer",
  snapPoints,
  direction = "bottom",
  handleOnly = false,
  dismissible = true,
  modal = true
} = Astro.props;
---

<div class="drawer-container">
  <div class="drawer-trigger" id={`${id}-trigger`}>
    <slot name="trigger">Open Drawer</slot>
  </div>

  <div class="drawer-overlay" id={`${id}-overlay`}></div>
  
  <div class="drawer" id={id} data-direction={direction}>
    <div class="drawer-handle" id={`${id}-handle`}>
      <div class="handle-indicator"></div>
    </div>
    <div class="drawer-content">
      <slot />
    </div>
  </div>
</div>

<style>
  .drawer-container {
    position: relative;
  }

  .drawer-overlay {
    position: fixed;
    inset: 0;
    background-color: rgba(0, 0, 0, 0.4);
    opacity: 0;
    pointer-events: none;
    z-index: 50;
    transition: opacity 0.5s cubic-bezier(0.32, 0.72, 0, 1);
  }

  .drawer {
    position: fixed;
    background: white;
    z-index: 51;
    border-radius: 8px 8px 0 0;
    transition: transform 0.5s cubic-bezier(0.32, 0.72, 0, 1);
    max-height: 90vh;
    overflow-y: auto;
    max-width: 100vw;
    padding: 16px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    touch-action: none;
  }

  .drawer[data-direction="bottom"] {
    bottom: 0;
    left: 0;
    right: 0;
    transform: translateY(100%);
  }

  .drawer[data-direction="top"] {
    top: 0;
    left: 0;
    right: 0;
    transform: translateY(-100%);
    border-radius: 0 0 8px 8px;
  }

  .drawer[data-direction="left"] {
    top: 0;
    left: 0;
    bottom: 0;
    transform: translateX(-100%);
    border-radius: 0 8px 8px 0;
  }

  .drawer[data-direction="right"] {
    top: 0;
    right: 0;
    bottom: 0;
    transform: translateX(100%);
    border-radius: 8px 0 0 8px;
  }

  .drawer.open[data-direction="bottom"] {
    transform: translateY(0);
  }

  .drawer.open[data-direction="top"] {
    transform: translateY(0);
  }

  .drawer.open[data-direction="left"] {
    transform: translateX(0);
  }

  .drawer.open[data-direction="right"] {
    transform: translateX(0);
  }

  .drawer-handle {
    display: flex;
    justify-content: center;
    padding: 10px 0;
    cursor: grab;
  }

  .handle-indicator {
    width: 32px;
    height: 5px;
    background-color: #e2e2e4;
    border-radius: 99px;
    opacity: 0.7;
  }

  .drawer-content {
    overflow-y: auto;
  }

  .drawer-overlay.open {
    opacity: 1;
    pointer-events: all;
  }

  /* Add style for close buttons */
  [data-drawer-close] {
    cursor: pointer;
  }
</style>

<script define:vars={{ id, direction, handleOnly, dismissible, snapPoints, modal }}>
document.addEventListener('DOMContentLoaded', () => {
  const drawer = document.getElementById(id);
  const overlay = document.getElementById(`${id}-overlay`);
  const trigger = document.getElementById(`${id}-trigger`);
  const handle = document.getElementById(`${id}-handle`);
  
  let isOpen = false;
  let startY = 0;
  let startX = 0;
  let currentY = 0;
  let currentX = 0;
  let initialTransform = 0;
  let isDragging = false;
  let activeSnapPoint = snapPoints ? snapPoints.length - 1 : null;
  
  // Calculate initial heights for snap points
  const getSnapPointValue = (point) => {
    if (typeof point === 'number') {
      // Percentage-based
      return window.innerHeight * (point / 100);
    }
    // Pixel-based
    return parseInt(point, 10);
  };
  
  const getVerticalTransform = () => {
    if (direction === 'top') {
      return -drawer.offsetHeight;
    }
    return drawer.offsetHeight;
  };
  
  const getHorizontalTransform = () => {
    if (direction === 'left') {
      return -drawer.offsetWidth;
    }
    return drawer.offsetWidth;
  };
  
  // Determine if vertical or horizontal direction
  const isVertical = direction === 'top' || direction === 'bottom';
  
  // Helper function for translate3d
  const setTransform = (el, x, y) => {
    el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
  };
  
  // Toggle drawer open/closed
  const toggleDrawer = (open = !isOpen) => {
    isOpen = open;
    
    if (open) {
      drawer.classList.add('open');
      overlay.classList.add('open');
      document.body.style.overflow = modal ? 'hidden' : '';
      
      // Set to highest snap point if snap points defined
      if (snapPoints && snapPoints.length) {
        activeSnapPoint = snapPoints.length - 1;
        const snapValue = getSnapPointValue(snapPoints[activeSnapPoint]);
        const translateY = isVertical ? 
          (direction === 'top' ? snapValue - drawer.offsetHeight : 0) : 
          0;
        const translateX = !isVertical ? 
          (direction === 'left' ? snapValue - drawer.offsetWidth : 0) : 
          0;
        setTransform(drawer, translateX, translateY);
      }
    } else {
      drawer.classList.remove('open');
      overlay.classList.remove('open');
      document.body.style.overflow = '';
    }
  };
  
  // Event listeners
  trigger.addEventListener('click', () => toggleDrawer(true));
  
  if (dismissible) {
    overlay.addEventListener('click', () => toggleDrawer(false));
    
    // Close when pressing escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && isOpen) {
        toggleDrawer(false);
      }
    });
  }
  
  // Drag implementation
  const getClientY = (e) => {
    return e.touches ? e.touches[0].clientY : e.clientY;
  };
  
  const getClientX = (e) => {
    return e.touches ? e.touches[0].clientX : e.clientX;
  };
  
  // Handle drag start
  const onDragStart = (e) => {
    // Only allow dragging on handle if handleOnly is true
    if (handleOnly && !e.target.closest('.drawer-handle')) {
      return;
    }
    
    isDragging = true;
    
    // Block text selection during drag
    document.body.style.userSelect = 'none';
    
    // Store start positions
    startY = getClientY(e);
    startX = getClientX(e);
    
    // Get current transform
    const transform = window.getComputedStyle(drawer).transform;
    const matrix = new DOMMatrix(transform);
    currentY = matrix.m42; // Y transform
    currentX = matrix.m41; // X transform
    
    // Add event listeners for move and end
    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('touchmove', onDragMove, { passive: false });
    document.addEventListener('mouseup', onDragEnd);
    document.addEventListener('touchend', onDragEnd);
  };
  
  // Handle drag movement
  const onDragMove = (e) => {
    if (!isDragging) return;
    
    // Prevent default to stop scrolling
    e.preventDefault();
    
    const y = getClientY(e);
    const x = getClientX(e);
    
    // Calculate new position
    let deltaY = y - startY;
    let deltaX = x - startX;
    
    let newY = currentY + deltaY;
    let newX = currentX + deltaX;
    
    // Clamp values based on direction
    if (direction === 'bottom') {
      newY = Math.max(0, newY); // Don't go above 0
    } else if (direction === 'top') {
      newY = Math.min(0, newY); // Don't go below 0
    } else if (direction === 'left') {
      newX = Math.min(0, newX); // Don't go below 0
    } else if (direction === 'right') {
      newX = Math.max(0, newX); // Don't go above 0
    }
    
    // Apply transform based on direction
    if (isVertical) {
      setTransform(drawer, 0, newY);
    } else {
      setTransform(drawer, newX, 0);
    }
    
    // Update overlay opacity if modal
    if (modal) {
      const maxOffset = isVertical ? getVerticalTransform() : getHorizontalTransform();
      const currentOffset = isVertical ? newY : newX;
      const percentClosed = Math.abs(currentOffset / maxOffset);
      overlay.style.opacity = 1 - percentClosed;
    }
  };
  
  // Handle drag end
  const onDragEnd = (e) => {
    if (!isDragging) return;
    
    // Clean up
    document.removeEventListener('mousemove', onDragMove);
    document.removeEventListener('touchmove', onDragMove);
    document.removeEventListener('mouseup', onDragEnd);
    document.removeEventListener('touchend', onDragEnd);
    document.body.style.userSelect = '';
    
    isDragging = false;
    
    const transform = window.getComputedStyle(drawer).transform;
    const matrix = new DOMMatrix(transform);
    const currentOffset = isVertical ? matrix.m42 : matrix.m41;
    const maxOffset = isVertical ? getVerticalTransform() : getHorizontalTransform();
    
    // Determine if should close or snap
    if (snapPoints && snapPoints.length) {
      // Find nearest snap point
      let closestSnapPoint = 0;
      let closestDistance = Infinity;
      
      snapPoints.forEach((point, index) => {
        const snapValue = getSnapPointValue(point);
        let snapPosition;
        
        if (isVertical) {
          snapPosition = direction === 'top' ? 
            snapValue - drawer.offsetHeight : 
            drawer.offsetHeight - snapValue;
        } else {
          snapPosition = direction === 'left' ? 
            snapValue - drawer.offsetWidth : 
            drawer.offsetWidth - snapValue;
        }
        
        const distance = Math.abs(currentOffset - snapPosition);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestSnapPoint = index;
        }
      });
      
      // Snap to closest point
      activeSnapPoint = closestSnapPoint;
      
      if (activeSnapPoint === 0 && closestDistance > 0.4 * maxOffset) {
        // Close drawer if dragged far enough
        toggleDrawer(false);
      } else {
        // Apply snap transform
        const snapValue = getSnapPointValue(snapPoints[activeSnapPoint]);
        
        if (isVertical) {
          const translateY = direction === 'top' ? 
            snapValue - drawer.offsetHeight : 
            drawer.offsetHeight - snapValue;
          setTransform(drawer, 0, translateY);
        } else {
          const translateX = direction === 'left' ? 
            snapValue - drawer.offsetWidth : 
            drawer.offsetWidth - snapValue;
          setTransform(drawer, translateX, 0);
        }
        
        // Update overlay opacity based on snap point
        if (modal && activeSnapPoint < snapPoints.length - 1) {
          const percent = activeSnapPoint / (snapPoints.length - 1);
          overlay.style.opacity = percent;
        }
      }
    } else {
      // Close if dragged more than 25% of the way
      const percentageDragged = Math.abs(currentOffset / maxOffset);
      if (percentageDragged > 0.25) {
        toggleDrawer(false);
      } else {
        // Reset position
        if (isVertical) {
          setTransform(drawer, 0, 0);
        } else {
          setTransform(drawer, 0, 0);
        }
        overlay.style.opacity = 1;
      }
    }
  };
  
  // Add drag events for drawer
  drawer.addEventListener('mousedown', onDragStart);
  drawer.addEventListener('touchstart', onDragStart, { passive: true });
  
  // Set up global access in multiple ways to ensure it works
  // 1. Legacy method (using ${id}DrawerDrawer)
  window[`${id}DrawerDrawer`] = {
    open: () => toggleDrawer(true),
    close: () => toggleDrawer(false),
    toggle: toggleDrawer
  };
  
  // 2. New method (using data-drawer-close attribute)
  document.addEventListener('click', (e) => {
    // Handle data-drawer-close buttons
    if (e.target.closest(`[data-drawer-close="${id}"]`)) {
      toggleDrawer(false);
    }
    
    // Handle inline onclick handlers that might be calling basicDrawerDrawer.close()
    if (e.target.hasAttribute('onclick')) {
      const onclickAttr = e.target.getAttribute('onclick');
      if (onclickAttr.includes(`${id}DrawerDrawer.close()`)) {
        e.preventDefault();
        toggleDrawer(false);
      }
    }
  });
  
  // Expose a direct way to close via a global function for this specific drawer
  window[`close${id}Drawer`] = () => toggleDrawer(false);
});
</script>
